package com.balt.ui{	import com.gs.TweenLite;		import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.GradientType;	import flash.display.Shape;	import flash.display.SimpleButton;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.filters.DropShadowFilter;	import flash.geom.Matrix;	import flash.geom.Rectangle;		/**	* Dynamic sizeable scrollbar	*/	    public class TScrollBar extends Sprite	{		private const TRACK_NAME:String = "scrollTrack";		private const FACE_NAME:String = "scrollFace";		private const STARTARROW_NAME:String = "startArrow";		private const ENDARROW_NAME:String = "endArrow";				private var _scrollBarBuilt:Boolean = false;		private var _scrollBarEnabled:Boolean;				private var _targetContent:DisplayObject;		private var _targetMask:Object;		private var contentCover:Sprite;				private var _scrollTrack:Sprite;		private var _scrollFace:Sprite;		private var _scrollFaceDetail:Sprite;		private var _startArrow:Sprite;		private var _endArrow:Sprite;		private var _outline:Sprite;				private var _trackColor:uint;		private var _faceColor:uint;		private var _extArrows:Boolean;		private var _negOverride:uint;				private var _scrollWidth:Number;    	private var _scrollHeight:Number;		private var _startMargin:Number;		private var _endMargin:Number;				private var _arrowsEnabled:Boolean = true;		private var _arrowMargin:Number;		private var _arrowIncrement:Number;		private var _arrowStepPoint:Number;				private var _contentDimension:Number;		private var _maskDimension:Number;		private var _scrollTrackDimension:Number;		private var _scrollFaceDimension:Number;		    	private var _scrollVertOrientation:Boolean;    	    	private var _scrollEffects:Boolean = false;						/**		* Instantiates a new scrollbar		* 		* @param content_mc The object to be scrolled ( defined here or at 'build' )		* @param mask_mc The object to scroll against ( defined here or at 'build' )		* @param scrollWidth The scrollbar width ( larger than height will create horizontal scroller )		* @param scrollHeight The scrollbar height ( larger than width will create vertical scroller )		* @param startMargin The optional margin of which to scroll beyond		* @param endMargin The optional margin of which to scroll up to		*/				public function TScrollBar( content_mc:DisplayObject = null, mask_mc:Object = null, scrollWidth:Number = 10, scrollHeight:Number = 100, startMargin:Number = 0, endMargin:Number = 0 ):void 		{				this._targetContent = content_mc;			this._targetMask = mask_mc;						this._scrollWidth = scrollWidth;			this._scrollHeight = scrollHeight;			this._startMargin = startMargin;			this._endMargin = endMargin;						this._arrowStepPoint = 1;			this._scrollVertOrientation = Boolean( this._scrollHeight > this._scrollWidth );						this.addEventListener( Event.ADDED_TO_STAGE, checkBuild );		}				/**		* Sets the scrollbar width		* 		* @param scrollWidth The scrollbar width used at build time.		*/						override public function set width( scrollWidth:Number ):void		{			if( this._scrollBarBuilt )			{				trace( "*** Scrollbar is already built." );				return;			}						this._scrollWidth = scrollWidth;				}				/**		* Sets the scrollbar height		* 		* @param scrollHeight The scrollbar height used at build time.		*/							override public function set height( scrollHeight:Number ):void		{			if( this._scrollBarBuilt )			{				trace( "*** Scrollbar is already built." );				return;			}						this._scrollHeight = scrollHeight;					}				/**		* Builds the scrollbar graphically or with supplies assets		* 		* @param content_mc The object to be scrolled ( defined here or at constructor )		* @param mask_mc The object to scroll against ( defined here or at constructor ) 		* @param extArrows Determines whether arrows are placed in or outside of the scrollbar		* @param trackColor The color of the scroll track ( ignored if assets are provided )		* @param faceColor The color of the scroll face ( ignored if assets are provided )		* @param outlineColor The optional color of the scrollbar stroke		* @param negOverride A number from 0-5 that determines whether to override automatic graphic shading & coloring on the track and/or arrows		*/						public function build( content_mc:DisplayObject=null, mask_mc:Object=null, extArrows:Boolean = false, trackColor:uint = 0x333333, faceColor:uint = 0xFFFFFF, outlineColor:uint = 0, negOverride:uint = 0 ):void		{			if( this._scrollBarBuilt )			{				trace( "*** Scrollbar is already built." );				return;			}			else this._scrollBarBuilt = true;						if( content_mc && mask_mc )			{				this._targetContent = content_mc;				this._targetMask = mask_mc;							}						if( !this._targetContent || !this._targetMask )			{				trace( "*** BUILD ERROR: Both the content and content masking clips must be defined." );				return;							}						var trackAsset:Boolean = false;			var faceAsset:Boolean = false;								if( this._scrollTrack ) trackAsset = true;			else this._scrollTrack = new Sprite();						if( this._scrollFace ) faceAsset = true;			else this._scrollFace = new Sprite();						this._trackColor = trackColor;			this._faceColor = faceColor			this._extArrows = extArrows;			this._negOverride = negOverride;						if( !this._arrowsEnabled ) this._extArrows = false;			var trackColorNegative:Boolean;			var arrowsColorNegative:Boolean;						switch( this._negOverride )			{				case 1:					trackColorNegative = false;					arrowsColorNegative = false;					break;				case 2:					trackColorNegative = true;					arrowsColorNegative = true;					break;					case 3:					trackColorNegative = true;					arrowsColorNegative = false;					break;				case 4:					trackColorNegative = false;					arrowsColorNegative = true;					break;									default:					trackColorNegative = Boolean( this._trackColor > this._faceColor );					arrowsColorNegative = Boolean( this._trackColor > this._faceColor );					break;			}						this.createArrows( arrowsColorNegative, Boolean( outlineColor ) );			if( !trackAsset ) this.createTrack( trackColorNegative );			if( !faceAsset ) this.createFace();			if( outlineColor ) this.createOutline( outlineColor );						this._scrollFace.buttonMode = true;			this._startArrow.buttonMode = true;			this._endArrow.buttonMode = true;			this._scrollTrack.mouseChildren = false;			this._scrollFace.mouseChildren = false;			this._scrollTrack.name = this.TRACK_NAME;			this._scrollFace.name = this.FACE_NAME;			this._startArrow.name = this.STARTARROW_NAME;			this._endArrow.name = this.ENDARROW_NAME;						addChild( this._scrollTrack );			if( this._outline ) addChild( this._outline );						if( this._arrowsEnabled ) addChild( this._startArrow );			if( this._arrowsEnabled ) addChild( this._endArrow );			addChild( this._scrollFace );			if( this._scrollFaceDetail ) addChild( this._scrollFaceDetail );						this.update();		}				/**		* Determines whether assets will be build with shadow effects		* 		* @param effects Toggles effects on or off for build		*/				public function set effects( effects:Boolean ):void		{			if( this._scrollBarBuilt )			{				trace( "*** Scrollbar is already built." );				return;			}						this._scrollEffects = effects;		}				/**		* Sets an asset to the scroll track		* 		* @param scrollTrack_mc The incoming track asset		*/				public function set trackAsset( scrollTrack_mc:Sprite ):void		{			if( this._scrollBarBuilt )			{				trace( "*** Scrollbar is already built." );				return;			}						if( !scrollTrack_mc || !scrollTrack_mc.width || !scrollTrack_mc.height )			{				trace( "*** ScrollTrack asset is empty & cannot be set." );				return;			}						this._scrollTrack = scrollTrack_mc;			if( this._scrollTrack.width > this._scrollWidth ) this._scrollWidth = this._scrollTrack.width;			if( this._scrollTrack.height > this._scrollHeight ) this._scrollHeight = this._scrollTrack.height;		}				/**		* Returns the current track asset		*/				public function get trackAsset():Sprite		{			return this._scrollTrack;		}				/**		* Sets an asset to the scroll face		* 		* @param scrollFace_mc The incoming face asset		*/				public function set faceAsset( scrollFace_mc:Sprite ):void		{			if( this._scrollBarBuilt )			{				trace( "*** Scrollbar is already built." );				return;			}						if( !scrollFace_mc || !scrollFace_mc.width || !scrollFace_mc.height )			{				trace( "*** ScrollFace asset is empty & cannot be set." );				return;			}						this._scrollFace = scrollFace_mc;			if( this._scrollVertOrientation && this._scrollFace.width > this._scrollWidth )			{				this._scrollWidth = this._scrollFace.width;				this._scrollFace.height = this._scrollHeight/10;			}			if( !this._scrollVertOrientation && this._scrollFace.height > this._scrollHeight )			{				this._scrollHeight = this._scrollFace.height;				this._scrollFace.width = this._scrollWidth/10;			}		}				/**		* Returns the current face asset		*/				public function get faceAsset():Sprite		{			return this._scrollFace;		}				/**		* Sets an asset to the scroll face detail		* 		* @param scrollFaceDetail_mc The incoming detail asset		*/				public function set detailAsset( scrollFaceDetail_mc:Sprite ):void		{			if( this._scrollBarBuilt )			{				trace( "*** Scrollbar is already built." );				return;			}						if( !scrollFaceDetail_mc || !scrollFaceDetail_mc.width || !scrollFaceDetail_mc.height )			{				trace( "*** Detail asset is empty & cannot be set." );				return;			}						this._scrollFaceDetail = scrollFaceDetail_mc;			this._scrollFaceDetail.mouseEnabled = false;		}				/**		* Returns the current detail asset		*/				public function get detailAsset():Sprite		{			return this._scrollFaceDetail;		}				/**		* Sets assets to the scroll arrows		* 		* @param arrow_mc The incoming arrows asset		*/				public function setArrowAssets( startArrow_mc:Sprite, endArrow_mc:Sprite ):void		{			if( this._scrollBarBuilt )			{				trace( "*** Scrollbar is already built." );				return;			}						if( !startArrow_mc || !endArrow_mc|| !startArrow_mc.width || !endArrow_mc.width || !startArrow_mc.height || !endArrow_mc.height )			{				trace( "*** One or more arrow asset is empty & cannot be set." );				return;			}						this._startArrow = startArrow_mc;			this._endArrow = endArrow_mc;				}				/**		* Returns the current arrow asset		*/				public function getArrowAssets():Sprite		{			return this._startArrow;		}				public function set arrowsEnabled( enable:Boolean ):void		{			this._arrowsEnabled = enable;		}				/**		* Sets the scroll arrows click increment		* 		* @param increment The arrows increment value		*/				public function set arrowIncrement( increment:Number ):void		{			this._arrowStepPoint = increment;		}			/**		* Sets the scroll face to a new position based on a 0-100 range		* 		* @param percent The incremental percentage of where to set the scroll face		*/					public function set scrubPosition( percent:uint ):void		{			if( !this._scrollBarEnabled ) return;			if( !this._scrollBarBuilt )			{				trace( "*** Scrollbar must be built before setting scrub position." );				return;			}			if( percent > 100 ) percent = 100;			var increment:Number = ( this._scrollTrackDimension - this._scrollFaceDimension ) / 100;			var newPosition:Number = increment * percent;			if( this._scrollVertOrientation )			{				this._scrollFace.y = newPosition + this._scrollTrack.y;			}			else			{				this._scrollFace.x = newPosition + this._scrollTrack.x;			}						this.scrollUpdate();		}				/**		* Updates the scrollbar display to the content		*/				public function update():void		{			if( this._scrollVertOrientation )			{				this._contentDimension = this._targetContent.height;				this._maskDimension = this._targetMask.height - ( this._startMargin + this._endMargin );				this._scrollTrackDimension = this._scrollTrack.height;								if( this._extArrows ) this._endArrow.y = this._scrollTrackDimension + this._scrollTrack.y + ( this._arrowMargin - this._endArrow.height );				else this._endArrow.y = this._scrollTrackDimension - this._endArrow.height - this._startArrow.y;										}			else			{				this._contentDimension = this._targetContent.width;				this._maskDimension = this._targetMask.width - ( this._startMargin + this._endMargin );				this._scrollTrackDimension = this._scrollTrack.width;								if( this._extArrows ) this._endArrow.x = this._scrollTrackDimension + this._scrollTrack.x + ( this._arrowMargin - this._endArrow.width );				else this._endArrow.x = this._scrollTrackDimension - this._endArrow.width - this._startArrow.x;							}									this._scrollFaceDimension = ( this._maskDimension*this._scrollTrackDimension/this._contentDimension );						// Scroll Bar ON/OFF			if( this._contentDimension > ( this._maskDimension - ( this._startMargin+this._endMargin ) ) )			{				TweenLite.to( this, 1, {autoAlpha:1} );				addAllListeners();				this.addEventListener( MouseEvent.MOUSE_OVER,scrollOver );								this._scrollBarEnabled = true;			}			else			{				TweenLite.to( this, 1, {autoAlpha:0} );				removeAllListeners();				this.removeEventListener( MouseEvent.MOUSE_OVER,scrollOver );								this._scrollBarEnabled = false;								return;			}			// size Scroll Face			if( this._scrollFaceDimension <= this._scrollTrackDimension )			{				if( this._scrollFaceDimension < 10 ) this._scrollFaceDimension = 10;								if( this._scrollVertOrientation ) TweenLite.to( this._scrollFace, 0.5, {height:this._scrollFaceDimension, onComplete:stopPos} );				else TweenLite.to( this._scrollFace, 0.5, {width:this._scrollFaceDimension, onComplete:stopPos} );			}			else			{				// IF SCROLLFACE CANNOT BE SIZED, THEN TURN OFF SCROLLBAR				TweenLite.to( this, 1, {autoAlpha:0} );				this.removeEventListener( MouseEvent.MOUSE_OVER,scrollOver );								this._scrollBarEnabled = false;								return;			}						// position Scroll Face			if( this._scrollVertOrientation )			{				var yCoord:Number = ( ( this._scrollTrackDimension/this._contentDimension )*( this._targetContent.y - ( this._targetMask.y + this._startMargin ) ) )*-1 ;								if( yCoord >= 0 ) this._scrollFace.y = yCoord + this._scrollTrack.y;			}			else			{				var xCoord:Number = ( ( this._scrollTrackDimension/this._contentDimension )*( this._targetContent.x - ( this._targetMask.x + this._startMargin ) ) )*-1 ;								if( xCoord >= 0 ) this._scrollFace.x = xCoord + this._scrollTrack.x;			}						if( this._scrollFaceDetail ) this._scrollFaceDetail.addEventListener( Event.ENTER_FRAME, posDetail );						function posDetail( evt:Event ):void			{					_scrollFaceDetail.x = ( _scrollFace.width - _scrollFaceDetail.width ) * 0.5 + _scrollFace.x;				_scrollFaceDetail.y = ( _scrollFace.height - _scrollFaceDetail.height ) * 0.5 + _scrollFace.y;			}						function stopPos():void			{					if( _scrollFaceDetail && _scrollFaceDetail.hasEventListener( Event.ENTER_FRAME ) ) _scrollFaceDetail.removeEventListener( Event.ENTER_FRAME, posDetail );			}		}				private function checkBuild( evt:Event ):void		{			this.removeEventListener( Event.ADDED_TO_STAGE, checkBuild );						if( !this._scrollBarBuilt ) trace( "*** Scrollbar should be built before adding to stage." );			else			{				// Scroll Bar ON/OFF				if( this._contentDimension > ( this._maskDimension - ( this._startMargin + this._endMargin ) ) )				{					this.alpha = 1;					this.visible = true;									}				else				{					this.alpha = 0;					this.visible = false;				}			}		}				//*****************************************************		// UTILITIES SECTION		//*****************************************************				private function createOutline( color:uint ):void		{			var shape:Sprite = new Sprite();			shape.graphics.lineStyle( .1, color );			shape.graphics.drawRect( 0.1, -0.1, this._scrollWidth - 0.2, this._scrollHeight );						this._outline = new Sprite();			this._outline.addChild( shape );						if( this._arrowMargin )			{				if( this._scrollVertOrientation ) this._outline.y += this._arrowMargin;				else this._outline.x += this._arrowMargin;			}		}				private function createTrack( colorNegative:Boolean ):void		{			var shape:Sprite = new Sprite();			var dropfilter:DropShadowFilter = new DropShadowFilter( 0, 0, 0x000000, 1.0, 5, 5, 0.5, 3, colorNegative, false, false );						if( this._arrowMargin )			{				if( this._scrollVertOrientation )				{					this._scrollTrack.y += this._arrowMargin;					this._scrollHeight -= this._arrowMargin * 2;				}				else				{					this._scrollTrack.x += this._arrowMargin;					this._scrollWidth -= this._arrowMargin * 2;									}			}						if( this._scrollEffects ) this._scrollTrack.filters = [dropfilter];			//else shape.graphics.lineStyle( .1, this._faceColor );						shape.graphics.beginFill( this._trackColor );			shape.graphics.drawRect( 0, 0, this._scrollWidth, this._scrollHeight );			shape.graphics.endFill();						this._scrollTrack.addChild( shape );		}				private function createFace():void		{			var shape:Sprite = new Sprite();			var dropfilter:DropShadowFilter = new DropShadowFilter( 0, 0, 0x666666, 1.0, 2, 2, 1.5, 3, true, false, false );			var faceWidth:Number;			var faceHeight:Number;									if( this._scrollVertOrientation )			{				faceWidth = this._scrollWidth;				faceHeight = this._scrollHeight/10;			}			else			{				faceWidth = this._scrollWidth/10;				faceHeight = this._scrollHeight;			}						if( this._scrollEffects ) this._scrollFace.filters = [dropfilter];			else shape.graphics.lineStyle( .1, this._trackColor );						shape.graphics.beginFill( this._faceColor );			shape.graphics.drawRect( 0, 0, faceWidth - 0.2, faceHeight - 0.2 );			shape.graphics.endFill();						this._scrollFace.addChild(shape);		}				private function createArrows( colorNegative:Boolean, hasOutline:Boolean ):void		{			// create buttons						var arrowDimension:Number;			var arrowScale:Number;			var startArrowMargin:Number;			var endArrowMargin:Number;						if(this._extArrows) arrowScale = 1;			else{ arrowScale = 0.75; }						if( this._scrollVertOrientation )			{				if( !_startArrow ) this._startArrow = this.buildArrowButton( colorNegative, "up" );				if( !_endArrow ) this._endArrow = this.buildArrowButton( colorNegative, "down" );								arrowDimension = this._scrollWidth*arrowScale;				endArrowMargin = arrowDimension/this._endArrow.width;				startArrowMargin = arrowDimension/this._startArrow.width;								this._startArrow.scaleX = this._startArrow.scaleY = startArrowMargin;				this._endArrow.scaleX = this._endArrow.scaleY = endArrowMargin;								this._startArrow.x = this._endArrow.x = ( this._scrollWidth - arrowDimension )/2;								if( !this._extArrows ) this._startArrow.y = ( this._scrollWidth - arrowDimension );				else this._arrowMargin = this._startArrow.width;			}			else			{				if( !_startArrow ) this._startArrow = this.buildArrowButton( colorNegative, "left" );				if( !_endArrow ) this._endArrow = this.buildArrowButton( colorNegative, "right" );												arrowDimension = this._scrollHeight*arrowScale;				endArrowMargin = arrowDimension/this._endArrow.height;				startArrowMargin = arrowDimension/this._startArrow.height;								this._startArrow.scaleX = this._startArrow.scaleY = startArrowMargin;				this._endArrow.scaleX = this._endArrow.scaleY = endArrowMargin;								this._startArrow.y = this._endArrow.y = ( this._scrollHeight - arrowDimension )/2;								if( !this._extArrows) this._startArrow.x = ( this._scrollHeight - arrowDimension );				else this._arrowMargin = this._startArrow.height;			}		}				private function buildArrowButton( colorNegative:Boolean, dirPoint:String ):Sprite		{			var buttonContainer:Sprite = new Sprite();			var curButton:SimpleButton = new SimpleButton();			var colorBase:uint;						if( colorNegative ) colorBase = 0x000000;			else colorBase = 0xFFFFFF;						var upState:Sprite = this.createTriangle( colorBase, [0.66, 0.38], dirPoint, true );			var overState:Sprite = this.createTriangle( colorBase, [1.0, 0.38], dirPoint, true );			var downState:Sprite = this.createTriangle( colorBase, [0.2, 0.38], dirPoint, true );						curButton.upState = upState;			curButton.overState = overState;			curButton.downState = downState;			curButton.hitTestState = upState;						buttonContainer.addChild( curButton );			return buttonContainer;		}				private function createTriangle( colorBase:uint, alphas:Array, dirPoint:String, margin:Boolean = false ):Sprite		{			var triangleClip:Sprite = new Sprite();			var triangleShape:Shape = new Shape();			var marginShape:Shape = new Shape();			var gradMatrix:Matrix = new Matrix();						if( dirPoint=="down" )			{				gradMatrix.createGradientBox(120, 120, 0, -40, -50);				triangleShape.graphics.beginGradientFill(GradientType.RADIAL, [colorBase, colorBase], alphas, [0, 95], gradMatrix);				triangleShape.graphics.lineTo(40, 0);				triangleShape.graphics.lineTo(20, 30);				triangleShape.graphics.lineTo(0, 0);								marginShape.graphics.beginFill( 0x000000, 0 );				marginShape.graphics.drawRect( 0, 0, triangleShape.width, triangleShape.height*1.25 );				marginShape.graphics.endFill();								if( margin ) triangleShape.y = marginShape.height;			}			else if( dirPoint=="left" )			{				gradMatrix.createGradientBox(120, 120, 0, -40, -42);				triangleShape.graphics.beginGradientFill(GradientType.RADIAL, [colorBase, colorBase], alphas, [0, 95], gradMatrix);				triangleShape.graphics.moveTo(30, 0);						triangleShape.graphics.lineTo(30, 40);				triangleShape.graphics.lineTo(0, 20);				triangleShape.graphics.lineTo(30, 0);								marginShape.graphics.beginFill( 0x000000, 0 );				marginShape.graphics.drawRect( 0, 0, triangleShape.width*1.25, triangleShape.height );				marginShape.graphics.endFill();								if( margin ) marginShape.x = triangleShape.width;					}			else if( dirPoint=="right" )			{				gradMatrix.createGradientBox(120, 120, 0, -50, -42);				triangleShape.graphics.beginGradientFill(GradientType.RADIAL, [colorBase, colorBase], alphas, [0, 95], gradMatrix);				triangleShape.graphics.lineTo(30, 20);				triangleShape.graphics.lineTo(0, 40);				triangleShape.graphics.lineTo(0, 0);								marginShape.graphics.beginFill( 0x000000, 0 );				marginShape.graphics.drawRect( 0, 0, triangleShape.width*1.25, triangleShape.height );				marginShape.graphics.endFill();								if( margin ) triangleShape.x = marginShape.width;					}			else			{				gradMatrix.createGradientBox(120, 120, 0, -40, -42);				triangleShape.graphics.beginGradientFill(GradientType.RADIAL, [colorBase, colorBase], alphas, [0, 95], gradMatrix);						triangleShape.graphics.moveTo(20, 0);				triangleShape.graphics.lineTo(40, 30);				triangleShape.graphics.lineTo(0, 30);				triangleShape.graphics.lineTo(20, 0);								marginShape.graphics.beginFill( 0x000000, 0 );				marginShape.graphics.drawRect( 0, 0, triangleShape.width, triangleShape.height*1.25 );				marginShape.graphics.endFill();								if( margin ) marginShape.y = triangleShape.height;			}						if( margin ) triangleClip.addChild( marginShape );			triangleClip.addChild( triangleShape );						return triangleClip;		}				private function getScrollGaps():Object		{			var gap:Object = new Object();			var startGapDiff:Number;			var endGapDiff:Number;						if( this._scrollVertOrientation ) startGapDiff = this._scrollFace.y - this._scrollTrack.y;			else startGapDiff = this._scrollFace.x - this._scrollTrack.x;						endGapDiff = this._scrollTrackDimension - ( startGapDiff + this._scrollFaceDimension );						gap.start = startGapDiff;			gap.end = endGapDiff;						return gap;		}				private function setIncrement( targetArrow:String ):void		{			var gap:Object = this.getScrollGaps();			var percent:Number = ( this._scrollTrackDimension - this._scrollFaceDimension )/100;			var stepPoint:Number = Math.abs( this._arrowStepPoint );			if( targetArrow==this.STARTARROW_NAME )			{				if( stepPoint > gap.start ) stepPoint = gap.start;				this._arrowIncrement = percent * -( stepPoint );								if( this._arrowIncrement > 0 ) this._arrowIncrement = 0;			}			else if( targetArrow==this.ENDARROW_NAME )			{				if( stepPoint > gap.end ) stepPoint = gap.end;				this._arrowIncrement = percent * stepPoint;								if( this._arrowIncrement < 0 ) this._arrowIncrement = 0;			}		}				//*****************************************************		// ACTIONS SECTION		//*****************************************************				private function onMouseWheelEvent( e:MouseEvent ):void		{			if( this._scrollVertOrientation )			{				var trackOffset:Number = _scrollTrack.y;								var maxScrollValue:Number = Math.min(_scrollFace.y-e.delta, (this._scrollTrackDimension - this._scrollFaceDimension)+trackOffset );				this._scrollFace.y = Math.max(trackOffset, maxScrollValue);							}			else			{				var xCoord:Number = this._scrollFace.x + e.delta;							if( xCoord < 0 ) xCoord = 0;				if( xCoord > this._scrollTrackDimension - this._scrollFaceDimension ) xCoord = this._scrollTrackDimension - this._scrollFaceDimension;				this._scrollFace.x = xCoord + this._scrollTrack.x;			}						scrollUpdate();					}				private function scrollOver( e:MouseEvent ):void		{			//stage.addEventListener( MouseEvent.MOUSE_WHEEL, onMouseWheelEvent );						this.addEventListener( MouseEvent.MOUSE_DOWN, scrollPress );		}						private function scrollOut( e:MouseEvent  ):void		{			// Allow invisible scoll margins			if( e.target.name == this.FACE_NAME ) return;						this._scrollFace.stopDrag();					//stage.removeEventListener( MouseEvent.MOUSE_WHEEL, onMouseWheelEvent );					stage.removeEventListener( MouseEvent.MOUSE_UP, scrollRelease );			this.removeEventListener( MouseEvent.MOUSE_DOWN, scrollPress );						this.removeEventListener( MouseEvent.MOUSE_OUT, scrollOut );			this.removeEventListener( Event.ENTER_FRAME, scrollUpdate );					this._arrowIncrement = undefined;		}				private function scrollPress( e:MouseEvent ):void		{			if( e.target.name == this.TRACK_NAME )			{				if( this._scrollVertOrientation )				{					if( this._scrollFace.y >= this.mouseY ) this._scrollFace.y = this.mouseY;					else this._scrollFace.y = this.mouseY - this._scrollFaceDimension;				}				else				{					if( this._scrollFace.x >= this.mouseX ) this._scrollFace.x = this.mouseX;					else this._scrollFace.x = this.mouseX - this._scrollFaceDimension;								}									scrollUpdate();			}			else			{				if( e.target.name == this.FACE_NAME )				{					var dragArea:Rectangle;										if(this._scrollVertOrientation)					{						dragArea = new Rectangle(this._scrollTrack.x, this._scrollTrack.y, this._scrollTrack.x, this._scrollTrackDimension - this._scrollFaceDimension);					} else{						dragArea = new Rectangle(this._scrollTrack.x, this._scrollTrack.y, this._scrollTrackDimension - this._scrollFaceDimension, this._scrollTrack.y);					}										this._scrollFace.startDrag(false, dragArea);									}								if( e.target.parent.name == this.STARTARROW_NAME || e.target.parent.name == this.ENDARROW_NAME ) this.setIncrement( e.target.parent.name );								stage.addEventListener( MouseEvent.MOUSE_UP, scrollRelease );				this.addEventListener( MouseEvent.MOUSE_OUT, scrollOut );					this.addEventListener( Event.ENTER_FRAME, scrollUpdate );					}		}				private function scrollRelease( e:MouseEvent ):void		{			this._scrollFace.stopDrag();			//stage.removeEventListener( MouseEvent.MOUSE_WHEEL, onMouseWheelEvent );				stage.removeEventListener( MouseEvent.MOUSE_UP, scrollRelease );			this.removeEventListener( MouseEvent.MOUSE_OUT, scrollOut );			this.removeEventListener( Event.ENTER_FRAME, scrollUpdate );						this._arrowIncrement = undefined;		}				private function scrollUpdate( e:Event=null ):void		{			var scrollRatio:Number;			var marginRatio:Number;			var maskArea:Number = this._targetMask.height - ( this._startMargin + this._endMargin );						if( this._scrollVertOrientation )			{				if( this._scrollFace.y <= this._scrollTrack.y && this._arrowIncrement && this._arrowIncrement<0 ) return;								if( this._scrollFace.y >= ( this._scrollTrackDimension - this._scrollFaceDimension + this._scrollTrack.y ) && this._arrowIncrement && this._arrowIncrement>0 ) return				if( this._arrowIncrement && this._arrowIncrement>0 )				{					this.setIncrement( this.ENDARROW_NAME );					this._scrollFace.y += this._arrowIncrement;					}				else if( this._arrowIncrement && this._arrowIncrement<0 )				{					this.setIncrement( this.STARTARROW_NAME );					this._scrollFace.y += this._arrowIncrement;					}								scrollRatio = ( this._contentDimension - this._maskDimension )/( this._scrollTrackDimension - this._scrollFaceDimension )*-1;								this._targetContent.y = ( ( this._scrollFace.y - this._scrollTrack.y ) * scrollRatio ) + ( this._targetMask.y + this._startMargin );			}			else			{				if( this._scrollFace.x <= this._scrollTrack.x && this._arrowIncrement && this._arrowIncrement<0 ) return;				if( this._scrollFace.x >= ( this._scrollTrackDimension - this._scrollFaceDimension + this._scrollTrack.x ) && this._arrowIncrement && this._arrowIncrement>0 ) return;								if(this._arrowIncrement) this._scrollFace.x += this._arrowIncrement;								scrollRatio = ( this._contentDimension - this._maskDimension )/( this._scrollTrackDimension - this._scrollFaceDimension )*-1;								this._targetContent.x = ( ( this._scrollFace.x - this._scrollTrack.x ) * scrollRatio ) + ( this._targetMask.x + this._startMargin );			}						if( this._scrollFaceDetail )			{				this._scrollFaceDetail.x = ( this._scrollFace.width - this._scrollFaceDetail.width ) * 0.5 + this._scrollFace.x;				this._scrollFaceDetail.y = ( this._scrollFace.height - this._scrollFaceDetail.height ) * 0.5 + this._scrollFace.y;			}		}		private function addAllListeners():void		{			_targetContent.addEventListener(MouseEvent.MOUSE_OVER, handleMaskOver);			_targetContent.addEventListener(MouseEvent.MOUSE_OUT, removeAllListeners)		}		private function handleMaskOver(event:MouseEvent):void		{			if(!_targetContent.hasEventListener(MouseEvent.MOUSE_WHEEL))_targetContent.addEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheelEvent)		}		private function removeAllListeners(event:MouseEvent = null):void		{			if(_targetContent.hasEventListener(MouseEvent.MOUSE_WHEEL))_targetContent.removeEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheelEvent);		}			}// end Class}