// A collection of utilities for dealing with paths and files.// @author: bruce epstein//package com.balt.util{	import com.balt.log.Log;	import com.balt.text.TextUtil;		public class PathUtil	{		protected static const DOT:String = ".";		protected static const COLON:String = ":";					// Mac path separator		protected static const SLASH:String = "/";					// Flash/Unix path separator			protected static const BACKSLASH:String = "\\";				// Escaped Windows path separator		protected static const COLON_SLASH_SLASH:String = "://";	// Beginning of http path				private static var _pathRoot:String = '';				public function PathUtil()		{			Log.traceMsg ("No real point in constructing the PathUtil class, as all the methods are static", Log.WARN);		}		public static function setPathRoot( rootMC:*, defSWF:String ):void		{			PathUtil._pathRoot = String( unescape( rootMC.loaderInfo.url ) ).split( defSWF )[0];		}				public static function get pathRoot():String		{			return PathUtil._pathRoot;		}						// Remove characters that are allowed in Mac/Unix paths but not Windows paths. Make the path cross-platform		// Beware of case-sensitivity differences between Unix and Mac/Windows, which this routine doesn't deal with.		public static function cleansePath (inPath:String):String {			// The following are not allowed in Windows filenames: \ / : * ? " < > |  (and no leading or trailing spaces)			// Trim spaces and get rid of question marks (escape them)?			var outString:String = TextUtil.replace (TextUtil.trimSpaces(inPath), "?", "Q");			//var outString:String = escape(TextUtil.trimSpaces(inPath));			if (outString != inPath) {				Log.traceMsg("Warning: string needed to be cleansed: " + TextUtil.quotes(inPath), Log.WARN);				Log.traceMsg("Cleansed to: " + TextUtil.quotes(outString), Log.WARN);			}			return outString;		}		// FIXME - should this use File.separator?		// Add a trailing file separator, such as a slash (useful when you need to concatenate paths)		public static function ensureTrailingSeparator(inPath:String, newSeparator:String = SLASH):String {			if (undefinedOrEmpty(inPath)) {				return TextUtil.EMPTY_STRING;			} else if (lastChar(inPath) != SLASH && lastChar(inPath) != BACKSLASH 					&& lastChar(inPath) != COLON && lastChar(inPath) != newSeparator) {				return inPath + newSeparator;			} else {				return inPath;			}		}		// Remove a trailing file separator (useful when you need to concatenate paths)		public static function removeTrailingSeparator(inPath:String, newSeparator:String = SLASH):String {			if (undefinedOrEmpty(inPath)) {				return TextUtil.EMPTY_STRING;			} else if (lastChar(inPath) == newSeparator) {				return TextUtil.deleteLastChar(inPath);			} else {				return inPath;			}		}				// Remove any trailing slash - not as generic as removeTrailingSeparator		public static function trimTrailingSlash(inPath:String):String {			if (undefinedOrEmpty(inPath)) {				return TextUtil.EMPTY_STRING;			} else if (lastChar(inPath) == SLASH && lastChar(inPath) == BACKSLASH) {				return TextUtil.stripLastChar(inPath);			} else {				return inPath;			}		}		// Ensure that a string begins with a slash (for creating paths)		public static function ensureLeadingSeparator(inPath:String, newSeparator:String = SLASH):String {			if (undefinedOrEmpty(inPath)) {				return newSeparator;			} else if (firstChar(inPath) != SLASH && firstChar(inPath) != BACKSLASH 					&& firstChar(inPath) != COLON && firstChar(inPath) != newSeparator) {				return newSeparator + inPath;			} else {				return inPath;			}		}		// Ensure that a filename has a given extension, adding it if necessary		public static function ensureExtension(inPath:String, extension:String):String {			if (firstChar(extension) == DOT) {				extension = TextUtil.stripFirstChar (extension);			}			//dump ("Extension is " + lastChar(inPath, DOT));			if (lastChar(inPath) == DOT) {				return inPath + extension;			} else if (!hasExtension(inPath, extension)) {				return inPath + DOT + extension;			} else {				return inPath;			}		}				public static function unitTest ():void {			Log.traceMsg("PathUtil unit test", Log.WARN);			return;			Log.traceMsg("Has extension 1 true: " + hasExtension("foo.swf", ".swf"));			Log.traceMsg("Has extension 2 true: " + hasExtension("foo.swf", "swf"));			Log.traceMsg("Has extension 3 true: " + hasExtension("foo.swf", [".swf"]));			Log.traceMsg("Has extension 4 true: " + hasExtension("foo.swf", ["swf"]));			Log.traceMsg("isSwfFormat 5 true: " + isSwfFormat("foo.swf"));			Log.traceMsg("isSwfFormat 6 false: " + isSwfFormat("foo.noswf"));			Log.traceMsg("isSwfFormat 7 false: " + isSwfFormat("foo.swfno"));			Log.traceMsg("isSwfFormat 8 false: " + isSwfFormat("fooswf"));			Log.traceMsg("isSwfFormat 9 false: " + isSwfFormat("swffoo"));			Log.traceMsg("isSwfFormat 10 false: " + isSwfFormat("nada"));			Log.traceMsg("isSwfFormat 11 false: " + isSwfFormat("foo.jpg"));			Log.traceMsg("isImageFormat 1 false: " + isImageFormat("foo"));			Log.traceMsg("isImageFormat 2 false: " + isImageFormat("foo.swf"));			Log.traceMsg("isImageFormat 3 true: " + isImageFormat("foo.png"));			Log.traceMsg("isImageFormat 4 true: " + isImageFormat("foo.PNG"));			Log.traceMsg("isImageFormat 5 true: " + isImageFormat("foo.pNg"));			Log.traceMsg("isImageFormat 6 true: " + isImageFormat("foo.gif"));			Log.traceMsg("isImageFormat 7 true: " + isImageFormat("foo.jpg"));			Log.traceMsg("isImageFormat 8 true: " + isImageFormat("foo.jpeg"));		}				// Returns true is file name ends in specified extension (case-insensitive, with or without dot)		public static function hasExtension (inPath:String, extensions:*):Boolean {			var extensionArray:Array;			// Create an array of a single extension, if it isn't an array already			if (extensions is String) {				extensionArray = [extensions];			} else {				extensionArray = extensions as Array;			}						var thisExt:String;			for (var i:int = 0; i < extensionArray.length; i++) {				thisExt = extensionArray[i].toLowerCase();				if (firstChar(thisExt) == DOT) {					thisExt = TextUtil.stripFirstChar(thisExt);				}				if (lastChar(inPath, DOT).toLowerCase() == thisExt) {					return true;				}			}			return false; 		}		// Returns true is file name ends in swf		public static function isSwfFormat (inPath:String):Boolean {			return hasExtension (inPath, "swf");		}				// Returns true is file name ends in jpg, png, or gif		public static function isImageFormat (inPath:String):Boolean {			return hasExtension (inPath, ["jpg", "jpeg", "png", "gif"]);   		}				// Returns true is file name ends in swf, jpg, png, or gif		public static function isImageOrSwfFormat (inPath:String):Boolean {			return isSwfFormat (inPath) || isImageFormat(inPath);		}				// Given an absolute path, strip off the specified portion to make the path relative, if necessary		public static function makePathRelative (fullPath:String, stripOffThisPart:String):String {			var outString:String = fullPath;			//if (stripOffThisPart == null) stripOffThisPart = App.mediaFolderString;			if (TextUtil.begins(fullPath, stripOffThisPart)) {				// Technically this should strip off the first occurence only				outString = TextUtil.replace (fullPath, stripOffThisPart, TextUtil.EMPTY_STRING);			}			return outString;		}		// If the path includes "://", then assume it is an absoluate path and not a relative one.		// Absolute paths may begin with "file:///C|" or "http://", for example.		public static function isRelativePath(inPath:String):Boolean {			if (TextUtil.undefinedOrEmpty(inPath)) {				return true;			} else if (inPath.indexOf(COLON_SLASH_SLASH) > 0) {				return false;			} else {				return true;			}		}		// Ensure that the path includes a trailing slash - more specific than ensureTrailingSeparator		public static function ensureTrailingSlash(inPath:String):String {			if (undefinedOrEmpty(inPath)) {				return TextUtil.EMPTY_STRING;			} else if (lastChar(inPath) != SLASH && lastChar(inPath) != BACKSLASH) {				return inPath + SLASH;			} else {				return inPath;			}		}		// Given a relative path, add a fixed portion to make the path absolute, if necessary.		public static function makePathAbsolute (relativePath:String, addThisPart:String):String {			var outString:String = relativePath;			//if (addThisPart == null) addThisPart = App.mediaFolderString;						if (!undefinedOrEmpty(relativePath) && !TextUtil.begins(relativePath, addThisPart)) {				// Technically this should check for other possible absolute paths first, such as those				// beginning with "C:/Users" and similar Mac paths.				outString = addThisPart + relativePath;			}			return outString;		}		// Extract the folder from a path (strip off the filename following the last path separator)		// and optionally include the trailing separator		public static function extractFolder(inPath:String, fileSep:String = null, includeTrailingSep:Boolean = true, trySlash:Boolean = true):String {			var retPath:String;						if (!fileSep) {				fileSep = SLASH;			} 						if (undefinedOrEmpty(inPath)) {				retPath = inPath;			} else {				var charLoc:int = inPath.lastIndexOf(fileSep);				if (charLoc > 0) {					retPath = inPath.substr(0, charLoc);				} else if (trySlash && fileSep != SLASH) {					// If it didn't work for a backslash or colon separator, try it with a SLASH separator					retPath =  extractFolder(inPath, SLASH, false, includeTrailingSep);				} else {					retPath = inPath;				}			}			if (includeTrailingSep) {				retPath = ensureTrailingSeparator(retPath, fileSep);			}			return retPath;		}		// Convenience functions (shorthand for invoking methods from TextUtil class		private static function firstChar (inString:String):String {			return TextUtil.firstChar (inString);		}				private static function lastChar (inString:String, afterChar:String = null):String {			return TextUtil.lastChar (inString, afterChar);		}				private static function undefinedOrEmpty (inString:String):Boolean {			return TextUtil.undefinedOrEmpty (inString);		}	}}